"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/lib/migrate-pain-data.ts":
/*!**************************************!*\
  !*** ./src/lib/migrate-pain-data.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMigrationBackup: function() { return /* binding */ createMigrationBackup; },\n/* harmony export */   getMigrationSummary: function() { return /* binding */ getMigrationSummary; },\n/* harmony export */   isLegacyEntry: function() { return /* binding */ isLegacyEntry; },\n/* harmony export */   isMigrationNeeded: function() { return /* binding */ isMigrationNeeded; },\n/* harmony export */   migrateAllLegacyEntries: function() { return /* binding */ migrateAllLegacyEntries; },\n/* harmony export */   migrateLegacyPainEntry: function() { return /* binding */ migrateLegacyPainEntry; },\n/* harmony export */   restoreMigrationBackup: function() { return /* binding */ restoreMigrationBackup; }\n/* harmony export */ });\n/**\r\n * Data migration utilities for converting from 30-region legacy system\r\n * to the new 60-region hierarchical system\r\n * \r\n * Strategy: Automatic migration on first app load\r\n * All legacy region IDs automatically map to new 60-region IDs\r\n * Intensity levels are copied to all subdivisions for mapped regions\r\n */ /**\r\n * Complete mapping table: Legacy 30-region IDs â†’ New 60-region IDs\r\n * \r\n * Format: One legacy ID can map to 1-4 new IDs\r\n * Each legacy region's intensity is copied to all mapped subdivisions\r\n */ const LEGACY_TO_NEW_60_MAPPING = {\n    // Neck (4 new IDs from 1 legacy)\n    left_neck: [\n        \"neck_left_anterior\",\n        \"neck_left_posterior\"\n    ],\n    right_neck: [\n        \"neck_right_anterior\",\n        \"neck_right_posterior\"\n    ],\n    // Shoulder (8 new IDs from 4 legacy: shoulder + deltoid variants)\n    left_shoulder: [\n        \"shoulder_left_superior\",\n        \"shoulder_left_inferior\"\n    ],\n    right_shoulder: [\n        \"shoulder_right_superior\",\n        \"shoulder_right_inferior\"\n    ],\n    left_deltoid: [\n        \"shoulder_left_superior\"\n    ],\n    right_deltoid: [\n        \"shoulder_right_superior\"\n    ],\n    // Arm (4 new IDs from 4 legacy: bicep and tricep variants)\n    left_bicep: [\n        \"arm_left_proximal\"\n    ],\n    right_bicep: [\n        \"arm_right_proximal\"\n    ],\n    left_tricep: [\n        \"arm_left_proximal\"\n    ],\n    right_tricep: [\n        \"arm_right_proximal\"\n    ],\n    // Forearm (4 new IDs from 1 legacy)\n    left_forearm: [\n        \"forearm_left_anterolateral\",\n        \"forearm_left_posterolateral\"\n    ],\n    right_forearm: [\n        \"forearm_right_anterolateral\",\n        \"forearm_right_posterolateral\"\n    ],\n    // Hand (4 new IDs from 1 legacy)\n    left_hand: [\n        \"hand_left_palma\",\n        \"hand_left_dorso\"\n    ],\n    right_hand: [\n        \"hand_right_palma\",\n        \"hand_right_dorso\"\n    ],\n    // Upper Back / Dorsales (4 new IDs from 1 legacy)\n    left_upper_back: [\n        \"dorsal_left_superior\",\n        \"dorsal_left_inferior\"\n    ],\n    right_upper_back: [\n        \"dorsal_right_superior\",\n        \"dorsal_right_inferior\"\n    ],\n    // Lower Back / Lumbares (4 new IDs from 1 legacy)\n    left_lower_back: [\n        \"lumbar_left_superior\",\n        \"lumbar_left_inferior\"\n    ],\n    right_lower_back: [\n        \"lumbar_right_superior\",\n        \"lumbar_right_inferior\"\n    ],\n    // Sacroiliac (4 new IDs from 1 legacy)\n    left_sacroiliac: [\n        \"sacroiliac_left_superior\",\n        \"sacroiliac_left_inferior\"\n    ],\n    right_sacroiliac: [\n        \"sacroiliac_right_superior\",\n        \"sacroiliac_right_inferior\"\n    ],\n    // Gluteal (4 new IDs from 1 legacy)\n    left_gluteal: [\n        \"gluteal_left_superior\",\n        \"gluteal_left_inferior\"\n    ],\n    right_gluteal: [\n        \"gluteal_right_superior\",\n        \"gluteal_right_inferior\"\n    ],\n    // Groin (4 new IDs from 1 legacy)\n    left_groin: [\n        \"groin_left_medial\",\n        \"groin_left_lateral\"\n    ],\n    right_groin: [\n        \"groin_right_medial\",\n        \"groin_right_lateral\"\n    ],\n    // Thigh (4 new IDs from 1 legacy)\n    left_thigh: [\n        \"thigh_left_anterior\",\n        \"thigh_left_posterior\"\n    ],\n    right_thigh: [\n        \"thigh_right_anterior\",\n        \"thigh_right_posterior\"\n    ],\n    // Knee (4 new IDs from 1 legacy)\n    left_knee: [\n        \"knee_left_lateral\",\n        \"knee_left_medial\"\n    ],\n    right_knee: [\n        \"knee_right_lateral\",\n        \"knee_right_medial\"\n    ],\n    // Shin / Calf (4 new IDs from 1 legacy)\n    left_shin: [\n        \"shin_left_anterior\",\n        \"shin_left_posterior\"\n    ],\n    right_shin: [\n        \"shin_right_anterior\",\n        \"shin_right_posterior\"\n    ],\n    // Ankle (4 new IDs from 1 legacy)\n    left_ankle: [\n        \"ankle_left_anterolateral\",\n        \"ankle_left_posterolateral\"\n    ],\n    right_ankle: [\n        \"ankle_right_anterolateral\",\n        \"ankle_right_posterolateral\"\n    ],\n    // Foot (4 new IDs from 1 legacy)\n    left_foot: [\n        \"foot_left_dorso\",\n        \"foot_left_planta\"\n    ],\n    right_foot: [\n        \"foot_right_dorso\",\n        \"foot_right_planta\"\n    ]\n};\n/**\r\n * Check if this is a legacy (30-region) pain entry\r\n * Detection logic: Entry uses old region ID format (legacy_{region})\r\n */ function isLegacyEntry(entry) {\n    var _entry_metadata;\n    const regionIds = Object.keys(entry.bodyPartEntries);\n    // If metadata indicates it's already migrated, it's not legacy\n    if (((_entry_metadata = entry.metadata) === null || _entry_metadata === void 0 ? void 0 : _entry_metadata.systemVersion) === \"refined-60\") {\n        return false;\n    }\n    // Check if any region ID is in the legacy mapping table\n    return regionIds.some((id)=>id in LEGACY_TO_NEW_60_MAPPING);\n}\n/**\r\n * Migrate a single legacy pain entry to 60-region format\r\n * \r\n * Process:\r\n * 1. Map each legacy region ID to new 60-region IDs\r\n * 2. Copy intensity level to all mapped subdivisions\r\n * 3. Preserve timestamps and metadata\r\n * 4. Mark as migrated\r\n */ function migrateLegacyPainEntry(entry) {\n    const newBodyPartEntries = {};\n    // Process each legacy region in the entry\n    Object.entries(entry.bodyPartEntries).forEach((param)=>{\n        let [legacyId, data] = param;\n        const newIds = LEGACY_TO_NEW_60_MAPPING[legacyId];\n        if (!newIds) {\n            // Unknown legacy ID - keep original for fallback\n            console.warn(\"Unknown legacy region ID during migration: \".concat(legacyId));\n            // Store with original ID to preserve data\n            newBodyPartEntries[legacyId] = data;\n            return;\n        }\n        // Distribute intensity across all new region IDs\n        newIds.forEach((newId)=>{\n            var _data_painType;\n            newBodyPartEntries[newId] = {\n                bodyPartId: newId,\n                intensityLevel: data.intensityLevel,\n                recordedAt: data.recordedAt,\n                notes: data.notes,\n                painType: (_data_painType = data.painType) !== null && _data_painType !== void 0 ? _data_painType : \"unknown\"\n            };\n        });\n    });\n    return {\n        date: entry.date,\n        bodyPartEntries: newBodyPartEntries,\n        createdAt: entry.createdAt,\n        updatedAt: new Date().toISOString(),\n        metadata: {\n            ...entry.metadata,\n            systemVersion: \"refined-60\",\n            migratedAt: new Date().toISOString()\n        }\n    };\n}\n/**\r\n * Migrate all legacy entries in a dataset\r\n * \r\n * Returns: Object with migration stats\r\n */ function migrateAllLegacyEntries(entries) {\n    const migratedEntries = {};\n    const errors = [];\n    let migratedCount = 0;\n    let skippedCount = 0;\n    Object.entries(entries).forEach((param)=>{\n        let [dateKey, entry] = param;\n        try {\n            if (isLegacyEntry(entry)) {\n                migratedEntries[dateKey] = migrateLegacyPainEntry(entry);\n                migratedCount++;\n            } else {\n                migratedEntries[dateKey] = entry;\n                skippedCount++;\n            }\n        } catch (error) {\n            errors.push(\"Error migrating entry for \".concat(dateKey, \": \").concat(error instanceof Error ? error.message : String(error)));\n            // Keep original entry on error for fallback\n            migratedEntries[dateKey] = entry;\n            skippedCount++;\n        }\n    });\n    const totalEntries = Object.keys(entries).length;\n    let migrationType = \"no-migration\";\n    if (migratedCount === 0) {\n        migrationType = \"no-migration\";\n    } else if (migratedCount === totalEntries) {\n        migrationType = \"complete\";\n    } else {\n        migrationType = \"partial\";\n    }\n    return {\n        migratedEntries,\n        migrationType,\n        stats: {\n            totalEntries,\n            migratedCount,\n            skippedCount,\n            errors\n        }\n    };\n}\n/**\r\n * Create a backup of entries before migration\r\n * For use in fallback scenarios\r\n */ function createMigrationBackup(entries) {\n    return JSON.stringify(entries, null, 2);\n}\n/**\r\n * Restore entries from a backup\r\n */ function restoreMigrationBackup(backupJson) {\n    try {\n        return JSON.parse(backupJson);\n    } catch (error) {\n        console.error(\"Failed to restore backup:\", error);\n        throw new Error(\"Invalid backup format\");\n    }\n}\n/**\r\n * Check if migration is needed\r\n * Returns true if there are any legacy entries\r\n */ function isMigrationNeeded(entries) {\n    return Object.values(entries).some((entry)=>isLegacyEntry(entry));\n}\n/**\r\n * Get migration summary for a dataset\r\n */ function getMigrationSummary(entries) {\n    let legacyEntryCount = 0;\n    let modernEntryCount = 0;\n    let totalRegionReferences = 0;\n    let estimatedNewRegions = 0;\n    Object.values(entries).forEach((entry)=>{\n        if (isLegacyEntry(entry)) {\n            legacyEntryCount++;\n        } else {\n            modernEntryCount++;\n        }\n        Object.keys(entry.bodyPartEntries).forEach((regionId)=>{\n            totalRegionReferences++;\n            const newIds = LEGACY_TO_NEW_60_MAPPING[regionId];\n            if (newIds) {\n                estimatedNewRegions += newIds.length;\n            } else {\n                estimatedNewRegions += 1;\n            }\n        });\n    });\n    return {\n        needsMigration: legacyEntryCount > 0,\n        legacyEntryCount,\n        modernEntryCount,\n        totalRegions: totalRegionReferences,\n        estimatedNewRegions\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTztZQUNMQztRQUNGO1FBRUFyRCxPQUFPQyxJQUFJLENBQUNILE1BQU1JLGVBQWUsRUFBRVEsT0FBTyxDQUFDLENBQUM4QztZQUMxQ0Y7WUFDQSxNQUFNekMsU0FBU25ELHdCQUF3QixDQUFDOEYsU0FBUztZQUNqRCxJQUFJM0MsUUFBUTtnQkFDVjBDLHVCQUF1QjFDLE9BQU8yQixNQUFNO1lBQ3RDLE9BQU87Z0JBQ0xlLHVCQUF1QjtZQUN6QjtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xFLGdCQUFnQkwsbUJBQW1CO1FBQ25DQTtRQUNBQztRQUNBSyxjQUFjSjtRQUNkQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9taWdyYXRlLXBhaW4tZGF0YS50cz82MTk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhaW5FbnRyeSwgQm9keVBhcnRFbnRyeSB9IGZyb20gJy4vZGF0YS1tb2RlbHMnO1xyXG5pbXBvcnQgdHlwZSB7IFBhaW5UeXBlQ29kZSB9IGZyb20gJy4vdHlwZXMvcGFpblR5cGUnO1xyXG5cclxuLyoqXHJcbiAqIERhdGEgbWlncmF0aW9uIHV0aWxpdGllcyBmb3IgY29udmVydGluZyBmcm9tIDMwLXJlZ2lvbiBsZWdhY3kgc3lzdGVtXHJcbiAqIHRvIHRoZSBuZXcgNjAtcmVnaW9uIGhpZXJhcmNoaWNhbCBzeXN0ZW1cclxuICogXHJcbiAqIFN0cmF0ZWd5OiBBdXRvbWF0aWMgbWlncmF0aW9uIG9uIGZpcnN0IGFwcCBsb2FkXHJcbiAqIEFsbCBsZWdhY3kgcmVnaW9uIElEcyBhdXRvbWF0aWNhbGx5IG1hcCB0byBuZXcgNjAtcmVnaW9uIElEc1xyXG4gKiBJbnRlbnNpdHkgbGV2ZWxzIGFyZSBjb3BpZWQgdG8gYWxsIHN1YmRpdmlzaW9ucyBmb3IgbWFwcGVkIHJlZ2lvbnNcclxuICovXHJcblxyXG4vKipcclxuICogQ29tcGxldGUgbWFwcGluZyB0YWJsZTogTGVnYWN5IDMwLXJlZ2lvbiBJRHMg4oaSIE5ldyA2MC1yZWdpb24gSURzXHJcbiAqIFxyXG4gKiBGb3JtYXQ6IE9uZSBsZWdhY3kgSUQgY2FuIG1hcCB0byAxLTQgbmV3IElEc1xyXG4gKiBFYWNoIGxlZ2FjeSByZWdpb24ncyBpbnRlbnNpdHkgaXMgY29waWVkIHRvIGFsbCBtYXBwZWQgc3ViZGl2aXNpb25zXHJcbiAqL1xyXG5jb25zdCBMRUdBQ1lfVE9fTkVXXzYwX01BUFBJTkc6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcclxuICAvLyBOZWNrICg0IG5ldyBJRHMgZnJvbSAxIGxlZ2FjeSlcclxuICBsZWZ0X25lY2s6IFsnbmVja19sZWZ0X2FudGVyaW9yJywgJ25lY2tfbGVmdF9wb3N0ZXJpb3InXSxcclxuICByaWdodF9uZWNrOiBbJ25lY2tfcmlnaHRfYW50ZXJpb3InLCAnbmVja19yaWdodF9wb3N0ZXJpb3InXSxcclxuXHJcbiAgLy8gU2hvdWxkZXIgKDggbmV3IElEcyBmcm9tIDQgbGVnYWN5OiBzaG91bGRlciArIGRlbHRvaWQgdmFyaWFudHMpXHJcbiAgbGVmdF9zaG91bGRlcjogWydzaG91bGRlcl9sZWZ0X3N1cGVyaW9yJywgJ3Nob3VsZGVyX2xlZnRfaW5mZXJpb3InXSxcclxuICByaWdodF9zaG91bGRlcjogWydzaG91bGRlcl9yaWdodF9zdXBlcmlvcicsICdzaG91bGRlcl9yaWdodF9pbmZlcmlvciddLFxyXG4gIGxlZnRfZGVsdG9pZDogWydzaG91bGRlcl9sZWZ0X3N1cGVyaW9yJ10sXHJcbiAgcmlnaHRfZGVsdG9pZDogWydzaG91bGRlcl9yaWdodF9zdXBlcmlvciddLFxyXG5cclxuICAvLyBBcm0gKDQgbmV3IElEcyBmcm9tIDQgbGVnYWN5OiBiaWNlcCBhbmQgdHJpY2VwIHZhcmlhbnRzKVxyXG4gIGxlZnRfYmljZXA6IFsnYXJtX2xlZnRfcHJveGltYWwnXSxcclxuICByaWdodF9iaWNlcDogWydhcm1fcmlnaHRfcHJveGltYWwnXSxcclxuICBsZWZ0X3RyaWNlcDogWydhcm1fbGVmdF9wcm94aW1hbCddLFxyXG4gIHJpZ2h0X3RyaWNlcDogWydhcm1fcmlnaHRfcHJveGltYWwnXSxcclxuXHJcbiAgLy8gRm9yZWFybSAoNCBuZXcgSURzIGZyb20gMSBsZWdhY3kpXHJcbiAgbGVmdF9mb3JlYXJtOiBbJ2ZvcmVhcm1fbGVmdF9hbnRlcm9sYXRlcmFsJywgJ2ZvcmVhcm1fbGVmdF9wb3N0ZXJvbGF0ZXJhbCddLFxyXG4gIHJpZ2h0X2ZvcmVhcm06IFsnZm9yZWFybV9yaWdodF9hbnRlcm9sYXRlcmFsJywgJ2ZvcmVhcm1fcmlnaHRfcG9zdGVyb2xhdGVyYWwnXSxcclxuXHJcbiAgLy8gSGFuZCAoNCBuZXcgSURzIGZyb20gMSBsZWdhY3kpXHJcbiAgbGVmdF9oYW5kOiBbJ2hhbmRfbGVmdF9wYWxtYScsICdoYW5kX2xlZnRfZG9yc28nXSxcclxuICByaWdodF9oYW5kOiBbJ2hhbmRfcmlnaHRfcGFsbWEnLCAnaGFuZF9yaWdodF9kb3JzbyddLFxyXG5cclxuICAvLyBVcHBlciBCYWNrIC8gRG9yc2FsZXMgKDQgbmV3IElEcyBmcm9tIDEgbGVnYWN5KVxyXG4gIGxlZnRfdXBwZXJfYmFjazogWydkb3JzYWxfbGVmdF9zdXBlcmlvcicsICdkb3JzYWxfbGVmdF9pbmZlcmlvciddLFxyXG4gIHJpZ2h0X3VwcGVyX2JhY2s6IFsnZG9yc2FsX3JpZ2h0X3N1cGVyaW9yJywgJ2RvcnNhbF9yaWdodF9pbmZlcmlvciddLFxyXG5cclxuICAvLyBMb3dlciBCYWNrIC8gTHVtYmFyZXMgKDQgbmV3IElEcyBmcm9tIDEgbGVnYWN5KVxyXG4gIGxlZnRfbG93ZXJfYmFjazogWydsdW1iYXJfbGVmdF9zdXBlcmlvcicsICdsdW1iYXJfbGVmdF9pbmZlcmlvciddLFxyXG4gIHJpZ2h0X2xvd2VyX2JhY2s6IFsnbHVtYmFyX3JpZ2h0X3N1cGVyaW9yJywgJ2x1bWJhcl9yaWdodF9pbmZlcmlvciddLFxyXG5cclxuICAvLyBTYWNyb2lsaWFjICg0IG5ldyBJRHMgZnJvbSAxIGxlZ2FjeSlcclxuICBsZWZ0X3NhY3JvaWxpYWM6IFsnc2Fjcm9pbGlhY19sZWZ0X3N1cGVyaW9yJywgJ3NhY3JvaWxpYWNfbGVmdF9pbmZlcmlvciddLFxyXG4gIHJpZ2h0X3NhY3JvaWxpYWM6IFsnc2Fjcm9pbGlhY19yaWdodF9zdXBlcmlvcicsICdzYWNyb2lsaWFjX3JpZ2h0X2luZmVyaW9yJ10sXHJcblxyXG4gIC8vIEdsdXRlYWwgKDQgbmV3IElEcyBmcm9tIDEgbGVnYWN5KVxyXG4gIGxlZnRfZ2x1dGVhbDogWydnbHV0ZWFsX2xlZnRfc3VwZXJpb3InLCAnZ2x1dGVhbF9sZWZ0X2luZmVyaW9yJ10sXHJcbiAgcmlnaHRfZ2x1dGVhbDogWydnbHV0ZWFsX3JpZ2h0X3N1cGVyaW9yJywgJ2dsdXRlYWxfcmlnaHRfaW5mZXJpb3InXSxcclxuXHJcbiAgLy8gR3JvaW4gKDQgbmV3IElEcyBmcm9tIDEgbGVnYWN5KVxyXG4gIGxlZnRfZ3JvaW46IFsnZ3JvaW5fbGVmdF9tZWRpYWwnLCAnZ3JvaW5fbGVmdF9sYXRlcmFsJ10sXHJcbiAgcmlnaHRfZ3JvaW46IFsnZ3JvaW5fcmlnaHRfbWVkaWFsJywgJ2dyb2luX3JpZ2h0X2xhdGVyYWwnXSxcclxuXHJcbiAgLy8gVGhpZ2ggKDQgbmV3IElEcyBmcm9tIDEgbGVnYWN5KVxyXG4gIGxlZnRfdGhpZ2g6IFsndGhpZ2hfbGVmdF9hbnRlcmlvcicsICd0aGlnaF9sZWZ0X3Bvc3RlcmlvciddLFxyXG4gIHJpZ2h0X3RoaWdoOiBbJ3RoaWdoX3JpZ2h0X2FudGVyaW9yJywgJ3RoaWdoX3JpZ2h0X3Bvc3RlcmlvciddLFxyXG5cclxuICAvLyBLbmVlICg0IG5ldyBJRHMgZnJvbSAxIGxlZ2FjeSlcclxuICBsZWZ0X2tuZWU6IFsna25lZV9sZWZ0X2xhdGVyYWwnLCAna25lZV9sZWZ0X21lZGlhbCddLFxyXG4gIHJpZ2h0X2tuZWU6IFsna25lZV9yaWdodF9sYXRlcmFsJywgJ2tuZWVfcmlnaHRfbWVkaWFsJ10sXHJcblxyXG4gIC8vIFNoaW4gLyBDYWxmICg0IG5ldyBJRHMgZnJvbSAxIGxlZ2FjeSlcclxuICBsZWZ0X3NoaW46IFsnc2hpbl9sZWZ0X2FudGVyaW9yJywgJ3NoaW5fbGVmdF9wb3N0ZXJpb3InXSxcclxuICByaWdodF9zaGluOiBbJ3NoaW5fcmlnaHRfYW50ZXJpb3InLCAnc2hpbl9yaWdodF9wb3N0ZXJpb3InXSxcclxuXHJcbiAgLy8gQW5rbGUgKDQgbmV3IElEcyBmcm9tIDEgbGVnYWN5KVxyXG4gIGxlZnRfYW5rbGU6IFsnYW5rbGVfbGVmdF9hbnRlcm9sYXRlcmFsJywgJ2Fua2xlX2xlZnRfcG9zdGVyb2xhdGVyYWwnXSxcclxuICByaWdodF9hbmtsZTogWydhbmtsZV9yaWdodF9hbnRlcm9sYXRlcmFsJywgJ2Fua2xlX3JpZ2h0X3Bvc3Rlcm9sYXRlcmFsJ10sXHJcblxyXG4gIC8vIEZvb3QgKDQgbmV3IElEcyBmcm9tIDEgbGVnYWN5KVxyXG4gIGxlZnRfZm9vdDogWydmb290X2xlZnRfZG9yc28nLCAnZm9vdF9sZWZ0X3BsYW50YSddLFxyXG4gIHJpZ2h0X2Zvb3Q6IFsnZm9vdF9yaWdodF9kb3JzbycsICdmb290X3JpZ2h0X3BsYW50YSddLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgaXMgYSBsZWdhY3kgKDMwLXJlZ2lvbikgcGFpbiBlbnRyeVxyXG4gKiBEZXRlY3Rpb24gbG9naWM6IEVudHJ5IHVzZXMgb2xkIHJlZ2lvbiBJRCBmb3JtYXQgKGxlZ2FjeV97cmVnaW9ufSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xlZ2FjeUVudHJ5KGVudHJ5OiBQYWluRW50cnkpOiBib29sZWFuIHtcclxuICBjb25zdCByZWdpb25JZHMgPSBPYmplY3Qua2V5cyhlbnRyeS5ib2R5UGFydEVudHJpZXMpO1xyXG4gIFxyXG4gIC8vIElmIG1ldGFkYXRhIGluZGljYXRlcyBpdCdzIGFscmVhZHkgbWlncmF0ZWQsIGl0J3Mgbm90IGxlZ2FjeVxyXG4gIGlmIChlbnRyeS5tZXRhZGF0YT8uc3lzdGVtVmVyc2lvbiA9PT0gJ3JlZmluZWQtNjAnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIENoZWNrIGlmIGFueSByZWdpb24gSUQgaXMgaW4gdGhlIGxlZ2FjeSBtYXBwaW5nIHRhYmxlXHJcbiAgcmV0dXJuIHJlZ2lvbklkcy5zb21lKChpZCkgPT4gaWQgaW4gTEVHQUNZX1RPX05FV182MF9NQVBQSU5HKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGUgYSBzaW5nbGUgbGVnYWN5IHBhaW4gZW50cnkgdG8gNjAtcmVnaW9uIGZvcm1hdFxyXG4gKiBcclxuICogUHJvY2VzczpcclxuICogMS4gTWFwIGVhY2ggbGVnYWN5IHJlZ2lvbiBJRCB0byBuZXcgNjAtcmVnaW9uIElEc1xyXG4gKiAyLiBDb3B5IGludGVuc2l0eSBsZXZlbCB0byBhbGwgbWFwcGVkIHN1YmRpdmlzaW9uc1xyXG4gKiAzLiBQcmVzZXJ2ZSB0aW1lc3RhbXBzIGFuZCBtZXRhZGF0YVxyXG4gKiA0LiBNYXJrIGFzIG1pZ3JhdGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWlncmF0ZUxlZ2FjeVBhaW5FbnRyeShlbnRyeTogUGFpbkVudHJ5KTogUGFpbkVudHJ5IHtcclxuICBjb25zdCBuZXdCb2R5UGFydEVudHJpZXM6IFJlY29yZDxzdHJpbmcsIEJvZHlQYXJ0RW50cnk+ID0ge307XHJcblxyXG4gIC8vIFByb2Nlc3MgZWFjaCBsZWdhY3kgcmVnaW9uIGluIHRoZSBlbnRyeVxyXG4gIE9iamVjdC5lbnRyaWVzKGVudHJ5LmJvZHlQYXJ0RW50cmllcykuZm9yRWFjaCgoW2xlZ2FjeUlkLCBkYXRhXSkgPT4ge1xyXG4gICAgY29uc3QgbmV3SWRzID0gTEVHQUNZX1RPX05FV182MF9NQVBQSU5HW2xlZ2FjeUlkXTtcclxuXHJcbiAgICBpZiAoIW5ld0lkcykge1xyXG4gICAgICAvLyBVbmtub3duIGxlZ2FjeSBJRCAtIGtlZXAgb3JpZ2luYWwgZm9yIGZhbGxiYWNrXHJcbiAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBsZWdhY3kgcmVnaW9uIElEIGR1cmluZyBtaWdyYXRpb246ICR7bGVnYWN5SWR9YCk7XHJcbiAgICAgIC8vIFN0b3JlIHdpdGggb3JpZ2luYWwgSUQgdG8gcHJlc2VydmUgZGF0YVxyXG4gICAgICBuZXdCb2R5UGFydEVudHJpZXNbbGVnYWN5SWRdID0gZGF0YTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3RyaWJ1dGUgaW50ZW5zaXR5IGFjcm9zcyBhbGwgbmV3IHJlZ2lvbiBJRHNcclxuICAgIG5ld0lkcy5mb3JFYWNoKChuZXdJZCkgPT4ge1xyXG4gICAgICBuZXdCb2R5UGFydEVudHJpZXNbbmV3SWRdID0ge1xyXG4gICAgICAgIGJvZHlQYXJ0SWQ6IG5ld0lkLFxyXG4gICAgICAgIGludGVuc2l0eUxldmVsOiBkYXRhLmludGVuc2l0eUxldmVsLFxyXG4gICAgICAgIHJlY29yZGVkQXQ6IGRhdGEucmVjb3JkZWRBdCxcclxuICAgICAgICBub3RlczogZGF0YS5ub3RlcyxcclxuICAgICAgICBwYWluVHlwZTogKGRhdGEucGFpblR5cGUgPz8gJ3Vua25vd24nKSBhcyBQYWluVHlwZUNvZGUsXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGRhdGU6IGVudHJ5LmRhdGUsXHJcbiAgICBib2R5UGFydEVudHJpZXM6IG5ld0JvZHlQYXJ0RW50cmllcyxcclxuICAgIGNyZWF0ZWRBdDogZW50cnkuY3JlYXRlZEF0LFxyXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICBtZXRhZGF0YToge1xyXG4gICAgICAuLi5lbnRyeS5tZXRhZGF0YSxcclxuICAgICAgc3lzdGVtVmVyc2lvbjogJ3JlZmluZWQtNjAnLFxyXG4gICAgICBtaWdyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNaWdyYXRlIGFsbCBsZWdhY3kgZW50cmllcyBpbiBhIGRhdGFzZXRcclxuICogXHJcbiAqIFJldHVybnM6IE9iamVjdCB3aXRoIG1pZ3JhdGlvbiBzdGF0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGVBbGxMZWdhY3lFbnRyaWVzKGVudHJpZXM6IFJlY29yZDxzdHJpbmcsIFBhaW5FbnRyeT4pOiB7XHJcbiAgbWlncmF0ZWRFbnRyaWVzOiBSZWNvcmQ8c3RyaW5nLCBQYWluRW50cnk+O1xyXG4gIG1pZ3JhdGlvblR5cGU6ICduby1taWdyYXRpb24nIHwgJ3BhcnRpYWwnIHwgJ2NvbXBsZXRlJztcclxuICBzdGF0czoge1xyXG4gICAgdG90YWxFbnRyaWVzOiBudW1iZXI7XHJcbiAgICBtaWdyYXRlZENvdW50OiBudW1iZXI7XHJcbiAgICBza2lwcGVkQ291bnQ6IG51bWJlcjtcclxuICAgIGVycm9yczogc3RyaW5nW107XHJcbiAgfTtcclxufSB7XHJcbiAgY29uc3QgbWlncmF0ZWRFbnRyaWVzOiBSZWNvcmQ8c3RyaW5nLCBQYWluRW50cnk+ID0ge307XHJcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGxldCBtaWdyYXRlZENvdW50ID0gMDtcclxuICBsZXQgc2tpcHBlZENvdW50ID0gMDtcclxuXHJcbiAgT2JqZWN0LmVudHJpZXMoZW50cmllcykuZm9yRWFjaCgoW2RhdGVLZXksIGVudHJ5XSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGlzTGVnYWN5RW50cnkoZW50cnkpKSB7XHJcbiAgICAgICAgbWlncmF0ZWRFbnRyaWVzW2RhdGVLZXldID0gbWlncmF0ZUxlZ2FjeVBhaW5FbnRyeShlbnRyeSk7XHJcbiAgICAgICAgbWlncmF0ZWRDb3VudCsrO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1pZ3JhdGVkRW50cmllc1tkYXRlS2V5XSA9IGVudHJ5O1xyXG4gICAgICAgIHNraXBwZWRDb3VudCsrO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBlcnJvcnMucHVzaChcclxuICAgICAgICBgRXJyb3IgbWlncmF0aW5nIGVudHJ5IGZvciAke2RhdGVLZXl9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIEtlZXAgb3JpZ2luYWwgZW50cnkgb24gZXJyb3IgZm9yIGZhbGxiYWNrXHJcbiAgICAgIG1pZ3JhdGVkRW50cmllc1tkYXRlS2V5XSA9IGVudHJ5O1xyXG4gICAgICBza2lwcGVkQ291bnQrKztcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgY29uc3QgdG90YWxFbnRyaWVzID0gT2JqZWN0LmtleXMoZW50cmllcykubGVuZ3RoO1xyXG4gIGxldCBtaWdyYXRpb25UeXBlOiAnbm8tbWlncmF0aW9uJyB8ICdwYXJ0aWFsJyB8ICdjb21wbGV0ZScgPSAnbm8tbWlncmF0aW9uJztcclxuXHJcbiAgaWYgKG1pZ3JhdGVkQ291bnQgPT09IDApIHtcclxuICAgIG1pZ3JhdGlvblR5cGUgPSAnbm8tbWlncmF0aW9uJztcclxuICB9IGVsc2UgaWYgKG1pZ3JhdGVkQ291bnQgPT09IHRvdGFsRW50cmllcykge1xyXG4gICAgbWlncmF0aW9uVHlwZSA9ICdjb21wbGV0ZSc7XHJcbiAgfSBlbHNlIHtcclxuICAgIG1pZ3JhdGlvblR5cGUgPSAncGFydGlhbCc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbWlncmF0ZWRFbnRyaWVzLFxyXG4gICAgbWlncmF0aW9uVHlwZSxcclxuICAgIHN0YXRzOiB7XHJcbiAgICAgIHRvdGFsRW50cmllcyxcclxuICAgICAgbWlncmF0ZWRDb3VudCxcclxuICAgICAgc2tpcHBlZENvdW50LFxyXG4gICAgICBlcnJvcnMsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBiYWNrdXAgb2YgZW50cmllcyBiZWZvcmUgbWlncmF0aW9uXHJcbiAqIEZvciB1c2UgaW4gZmFsbGJhY2sgc2NlbmFyaW9zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWlncmF0aW9uQmFja3VwKGVudHJpZXM6IFJlY29yZDxzdHJpbmcsIFBhaW5FbnRyeT4pOiBzdHJpbmcge1xyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlbnRyaWVzLCBudWxsLCAyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc3RvcmUgZW50cmllcyBmcm9tIGEgYmFja3VwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZU1pZ3JhdGlvbkJhY2t1cChiYWNrdXBKc29uOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBQYWluRW50cnk+IHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYmFja3VwSnNvbik7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZXN0b3JlIGJhY2t1cDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFja3VwIGZvcm1hdCcpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIG1pZ3JhdGlvbiBpcyBuZWVkZWRcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgbGVnYWN5IGVudHJpZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc01pZ3JhdGlvbk5lZWRlZChlbnRyaWVzOiBSZWNvcmQ8c3RyaW5nLCBQYWluRW50cnk+KTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZW50cmllcykuc29tZSgoZW50cnkpID0+IGlzTGVnYWN5RW50cnkoZW50cnkpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBtaWdyYXRpb24gc3VtbWFyeSBmb3IgYSBkYXRhc2V0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlncmF0aW9uU3VtbWFyeShlbnRyaWVzOiBSZWNvcmQ8c3RyaW5nLCBQYWluRW50cnk+KToge1xyXG4gIG5lZWRzTWlncmF0aW9uOiBib29sZWFuO1xyXG4gIGxlZ2FjeUVudHJ5Q291bnQ6IG51bWJlcjtcclxuICBtb2Rlcm5FbnRyeUNvdW50OiBudW1iZXI7XHJcbiAgdG90YWxSZWdpb25zOiBudW1iZXI7XHJcbiAgZXN0aW1hdGVkTmV3UmVnaW9uczogbnVtYmVyO1xyXG59IHtcclxuICBsZXQgbGVnYWN5RW50cnlDb3VudCA9IDA7XHJcbiAgbGV0IG1vZGVybkVudHJ5Q291bnQgPSAwO1xyXG4gIGxldCB0b3RhbFJlZ2lvblJlZmVyZW5jZXMgPSAwO1xyXG4gIGxldCBlc3RpbWF0ZWROZXdSZWdpb25zID0gMDtcclxuXHJcbiAgT2JqZWN0LnZhbHVlcyhlbnRyaWVzKS5mb3JFYWNoKChlbnRyeSkgPT4ge1xyXG4gICAgaWYgKGlzTGVnYWN5RW50cnkoZW50cnkpKSB7XHJcbiAgICAgIGxlZ2FjeUVudHJ5Q291bnQrKztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1vZGVybkVudHJ5Q291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3Qua2V5cyhlbnRyeS5ib2R5UGFydEVudHJpZXMpLmZvckVhY2goKHJlZ2lvbklkKSA9PiB7XHJcbiAgICAgIHRvdGFsUmVnaW9uUmVmZXJlbmNlcysrO1xyXG4gICAgICBjb25zdCBuZXdJZHMgPSBMRUdBQ1lfVE9fTkVXXzYwX01BUFBJTkdbcmVnaW9uSWRdO1xyXG4gICAgICBpZiAobmV3SWRzKSB7XHJcbiAgICAgICAgZXN0aW1hdGVkTmV3UmVnaW9ucyArPSBuZXdJZHMubGVuZ3RoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVzdGltYXRlZE5ld1JlZ2lvbnMgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuZWVkc01pZ3JhdGlvbjogbGVnYWN5RW50cnlDb3VudCA+IDAsXHJcbiAgICBsZWdhY3lFbnRyeUNvdW50LFxyXG4gICAgbW9kZXJuRW50cnlDb3VudCxcclxuICAgIHRvdGFsUmVnaW9uczogdG90YWxSZWdpb25SZWZlcmVuY2VzLFxyXG4gICAgZXN0aW1hdGVkTmV3UmVnaW9ucyxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJMRUdBQ1lfVE9fTkVXXzYwX01BUFBJTkciLCJsZWZ0X25lY2siLCJyaWdodF9uZWNrIiwibGVmdF9zaG91bGRlciIsInJpZ2h0X3Nob3VsZGVyIiwibGVmdF9kZWx0b2lkIiwicmlnaHRfZGVsdG9pZCIsImxlZnRfYmljZXAiLCJyaWdodF9iaWNlcCIsImxlZnRfdHJpY2VwIiwicmlnaHRfdHJpY2VwIiwibGVmdF9mb3JlYXJtIiwicmlnaHRfZm9yZWFybSIsImxlZnRfaGFuZCIsInJpZ2h0X2hhbmQiLCJsZWZ0X3VwcGVyX2JhY2siLCJyaWdodF91cHBlcl9iYWNrIiwibGVmdF9sb3dlcl9iYWNrIiwicmlnaHRfbG93ZXJfYmFjayIsImxlZnRfc2Fjcm9pbGlhYyIsInJpZ2h0X3NhY3JvaWxpYWMiLCJsZWZ0X2dsdXRlYWwiLCJyaWdodF9nbHV0ZWFsIiwibGVmdF9ncm9pbiIsInJpZ2h0X2dyb2luIiwibGVmdF90aGlnaCIsInJpZ2h0X3RoaWdoIiwibGVmdF9rbmVlIiwicmlnaHRfa25lZSIsImxlZnRfc2hpbiIsInJpZ2h0X3NoaW4iLCJsZWZ0X2Fua2xlIiwicmlnaHRfYW5rbGUiLCJsZWZ0X2Zvb3QiLCJyaWdodF9mb290IiwiaXNMZWdhY3lFbnRyeSIsImVudHJ5IiwicmVnaW9uSWRzIiwiT2JqZWN0Iiwia2V5cyIsImJvZHlQYXJ0RW50cmllcyIsIm1ldGFkYXRhIiwic3lzdGVtVmVyc2lvbiIsInNvbWUiLCJpZCIsIm1pZ3JhdGVMZWdhY3lQYWluRW50cnkiLCJuZXdCb2R5UGFydEVudHJpZXMiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImxlZ2FjeUlkIiwiZGF0YSIsIm5ld0lkcyIsImNvbnNvbGUiLCJ3YXJuIiwibmV3SWQiLCJib2R5UGFydElkIiwiaW50ZW5zaXR5TGV2ZWwiLCJyZWNvcmRlZEF0Iiwibm90ZXMiLCJwYWluVHlwZSIsImRhdGUiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJtaWdyYXRlZEF0IiwibWlncmF0ZUFsbExlZ2FjeUVudHJpZXMiLCJtaWdyYXRlZEVudHJpZXMiLCJlcnJvcnMiLCJtaWdyYXRlZENvdW50Iiwic2tpcHBlZENvdW50IiwiZGF0ZUtleSIsImVycm9yIiwicHVzaCIsIkVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsInRvdGFsRW50cmllcyIsImxlbmd0aCIsIm1pZ3JhdGlvblR5cGUiLCJzdGF0cyIsImNyZWF0ZU1pZ3JhdGlvbkJhY2t1cCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN0b3JlTWlncmF0aW9uQmFja3VwIiwiYmFja3VwSnNvbiIsInBhcnNlIiwiaXNNaWdyYXRpb25OZWVkZWQiLCJ2YWx1ZXMiLCJnZXRNaWdyYXRpb25TdW1tYXJ5IiwibGVnYWN5RW50cnlDb3VudCIsIm1vZGVybkVudHJ5Q291bnQiLCJ0b3RhbFJlZ2lvblJlZmVyZW5jZXMiLCJlc3RpbWF0ZWROZXdSZWdpb25zIiwicmVnaW9uSWQiLCJuZWVkc01pZ3JhdGlvbiIsInRvdGFsUmVnaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/migrate-pain-data.ts\n"));

/***/ })

});