"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/history",{

/***/ "./src/lib/hooks/usePainData.ts":
/*!**************************************!*\
  !*** ./src/lib/hooks/usePainData.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePainData: function() { return /* binding */ usePainData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../storage */ \"./src/lib/storage.ts\");\n/* harmony import */ var _dates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dates */ \"./src/lib/dates.ts\");\n/* harmony import */ var _migrate_pain_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../migrate-pain-data */ \"./src/lib/migrate-pain-data.ts\");\n/* __next_internal_client_entry_do_not_use__ usePainData auto */ \n\n\n\nfunction usePainData() {\n    const [entries, setEntries] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [migrationStatus, setMigrationStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"pending\");\n    const [migrationSummary, setMigrationSummary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Load data on mount and detect if migration is needed (do NOT auto-migrate)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        try {\n            const data = (0,_storage__WEBPACK_IMPORTED_MODULE_1__.loadPainTrackerData)();\n            // Compute migration summary and set status if legacy data present\n            if ((0,_migrate_pain_data__WEBPACK_IMPORTED_MODULE_3__.isMigrationNeeded)(data)) {\n                try {\n                    const summary = (0,_migrate_pain_data__WEBPACK_IMPORTED_MODULE_3__.getMigrationSummary)(data);\n                    setMigrationSummary(summary);\n                } catch (e) {\n                    console.warn(\"Failed to compute migration summary\", e);\n                }\n                // Do NOT perform migration automatically; mark as needs-migration\n                setMigrationStatus(\"needs-migration\");\n            } else {\n                setMigrationStatus(\"no-migration\");\n            }\n            setEntries(data);\n        } catch (err) {\n            setError(\"Failed to load pain data\");\n            console.error(err);\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    // Manual migration trigger: call this when user chooses to migrate\n    const performMigration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        try {\n            const current = (0,_storage__WEBPACK_IMPORTED_MODULE_1__.loadPainTrackerData)();\n            // Create backup before migration\n            const backupJson = (0,_migrate_pain_data__WEBPACK_IMPORTED_MODULE_3__.createMigrationBackup)(current);\n            sessionStorage.setItem(\"painDataBackup\", backupJson);\n            const { migratedEntries, migrationType, stats } = (0,_migrate_pain_data__WEBPACK_IMPORTED_MODULE_3__.migrateAllLegacyEntries)(current);\n            console.log(\"✅ Migration complete: \".concat(migrationType), stats);\n            // Save migrated data back to localStorage and update state\n            (0,_storage__WEBPACK_IMPORTED_MODULE_1__.savePainTrackerData)(migratedEntries);\n            setEntries(migratedEntries);\n            setMigrationStatus(migrationType === \"no-migration\" ? \"no-migration\" : \"migrated\");\n        } catch (migrationError) {\n            console.error(\"❌ Migration error:\", migrationError);\n            setMigrationStatus(\"error\");\n            setError(\"Migration failed: \".concat(migrationError instanceof Error ? migrationError.message : \"Unknown error\"));\n        }\n    }, []);\n    const recordPain = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((bodyPartId, intensityLevel, painType)=>{\n        try {\n            const entry = (0,_storage__WEBPACK_IMPORTED_MODULE_1__.addPainEntry)(bodyPartId, intensityLevel, painType);\n            setEntries((prev)=>({\n                    ...prev,\n                    [entry.date]: entry\n                }));\n            return entry;\n        } catch (err) {\n            const message = \"Failed to record pain: \".concat(err instanceof Error ? err.message : \"Unknown error\");\n            setError(message);\n            throw err;\n        }\n    }, []);\n    const updatePain = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((date, bodyPartId, intensityLevel, painType)=>{\n        try {\n            const entry = (0,_storage__WEBPACK_IMPORTED_MODULE_1__.updatePainLevel)(date, bodyPartId, intensityLevel, painType);\n            setEntries((prev)=>({\n                    ...prev,\n                    [date]: entry\n                }));\n            return entry;\n        } catch (err) {\n            const message = \"Failed to update pain: \".concat(err instanceof Error ? err.message : \"Unknown error\");\n            setError(message);\n            throw err;\n        }\n    }, []);\n    const removePain = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((date, bodyPartId)=>{\n        try {\n            (0,_storage__WEBPACK_IMPORTED_MODULE_1__.deletePainLevelFromDate)(date, bodyPartId);\n            setEntries((prev)=>{\n                const newEntries = {\n                    ...prev\n                };\n                if (newEntries[date]) {\n                    delete newEntries[date].bodyPartEntries[bodyPartId];\n                    if (Object.keys(newEntries[date].bodyPartEntries).length === 0) {\n                        delete newEntries[date];\n                    } else {\n                        newEntries[date].updatedAt = new Date().toISOString();\n                    }\n                }\n                return newEntries;\n            });\n        } catch (err) {\n            const message = \"Failed to remove pain: \".concat(err instanceof Error ? err.message : \"Unknown error\");\n            setError(message);\n            throw err;\n        }\n    }, []);\n    const getTodayEntry = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return entries[(0,_dates__WEBPACK_IMPORTED_MODULE_2__.getTodayString)()] || null;\n    }, [\n        entries\n    ]);\n    const getEntryByDate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((date)=>{\n        return entries[date] || null;\n    }, [\n        entries\n    ]);\n    const getAllEntries = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return Object.values(entries).sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n    }, [\n        entries\n    ]);\n    return {\n        entries,\n        loading,\n        error,\n        migrationStatus,\n        migrationSummary,\n        performMigration,\n        recordPain,\n        updatePain,\n        removePain,\n        getTodayEntry,\n        getEntryByDate,\n        getAllEntries,\n        clearError: ()=>setError(null),\n        acknowledgeMigration: ()=>setMigrationStatus(\"no-migration\")\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL2hvb2tzL3VzZVBhaW5EYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztpRUFFeUQ7QUFRckM7QUFDc0I7QUFNWjtBQUV2QixTQUFTYTtJQUNkLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHZiwrQ0FBUUEsQ0FBNEIsQ0FBQztJQUNuRSxNQUFNLENBQUNnQixTQUFTQyxXQUFXLEdBQUdqQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNrQixPQUFPQyxTQUFTLEdBQUduQiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDb0IsaUJBQWlCQyxtQkFBbUIsR0FBR3JCLCtDQUFRQSxDQUF3RTtJQUM5SCxNQUFNLENBQUNzQixrQkFBa0JDLG9CQUFvQixHQUFHdkIsK0NBQVFBLENBQWE7SUFFckUsNkVBQTZFO0lBQzdFQyxnREFBU0EsQ0FBQztRQUNSLElBQUk7WUFDRixNQUFNdUIsT0FBT3JCLDZEQUFtQkE7WUFFaEMsa0VBQWtFO1lBQ2xFLElBQUlNLHFFQUFpQkEsQ0FBQ2UsT0FBTztnQkFDM0IsSUFBSTtvQkFDRixNQUFNQyxVQUFVYix1RUFBbUJBLENBQUNZO29CQUNwQ0Qsb0JBQW9CRTtnQkFDdEIsRUFBRSxPQUFPQyxHQUFHO29CQUNWQyxRQUFRQyxJQUFJLENBQUMsdUNBQXVDRjtnQkFDdEQ7Z0JBRUEsa0VBQWtFO2dCQUNsRUwsbUJBQW1CO1lBQ3JCLE9BQU87Z0JBQ0xBLG1CQUFtQjtZQUNyQjtZQUVBTixXQUFXUztRQUNiLEVBQUUsT0FBT0ssS0FBSztZQUNaVixTQUFTO1lBQ1RRLFFBQVFULEtBQUssQ0FBQ1c7UUFDaEIsU0FBVTtZQUNSWixXQUFXO1FBQ2I7SUFDRixHQUFHLEVBQUU7SUFFTCxtRUFBbUU7SUFDbkUsTUFBTWEsbUJBQW1CNUIsa0RBQVdBLENBQUM7UUFDbkMsSUFBSTtZQUNGLE1BQU02QixVQUFVNUIsNkRBQW1CQTtZQUVuQyxpQ0FBaUM7WUFDakMsTUFBTTZCLGFBQWFyQix5RUFBcUJBLENBQUNvQjtZQUN6Q0UsZUFBZUMsT0FBTyxDQUFDLGtCQUFrQkY7WUFFekMsTUFBTSxFQUFFRyxlQUFlLEVBQUVDLGFBQWEsRUFBRUMsS0FBSyxFQUFFLEdBQUczQiwyRUFBdUJBLENBQUNxQjtZQUMxRUosUUFBUVcsR0FBRyxDQUFDLHlCQUF1QyxPQUFkRixnQkFBaUJDO1lBRXRELDJEQUEyRDtZQUMzRDlCLDZEQUFtQkEsQ0FBQzRCO1lBQ3BCcEIsV0FBV29CO1lBQ1hkLG1CQUFtQmUsa0JBQWtCLGlCQUFpQixpQkFBaUI7UUFDekUsRUFBRSxPQUFPRyxnQkFBZ0I7WUFDdkJaLFFBQVFULEtBQUssQ0FBQyxzQkFBc0JxQjtZQUNwQ2xCLG1CQUFtQjtZQUNuQkYsU0FBUyxxQkFBZ0csT0FBM0VvQiwwQkFBMEJDLFFBQVFELGVBQWVFLE9BQU8sR0FBRztRQUMzRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU1DLGFBQWF4QyxrREFBV0EsQ0FDNUIsQ0FBQ3lDLFlBQW9CQyxnQkFBd0JDO1FBQzNDLElBQUk7WUFDRixNQUFNQyxRQUFRMUMsc0RBQVlBLENBQUN1QyxZQUFZQyxnQkFBZ0JDO1lBQ3ZEOUIsV0FBVyxDQUFDZ0MsT0FBVTtvQkFDcEIsR0FBR0EsSUFBSTtvQkFDUCxDQUFDRCxNQUFNRSxJQUFJLENBQUMsRUFBRUY7Z0JBQ2hCO1lBQ0EsT0FBT0E7UUFDVCxFQUFFLE9BQU9qQixLQUFLO1lBQ1osTUFBTVksVUFBVSwwQkFBK0UsT0FBckRaLGVBQWVXLFFBQVFYLElBQUlZLE9BQU8sR0FBRztZQUMvRXRCLFNBQVNzQjtZQUNULE1BQU1aO1FBQ1I7SUFDRixHQUNBLEVBQUU7SUFHSixNQUFNb0IsYUFBYS9DLGtEQUFXQSxDQUM1QixDQUFDOEMsTUFBY0wsWUFBb0JDLGdCQUF3QkM7UUFDekQsSUFBSTtZQUNGLE1BQU1DLFFBQVF6Qyx5REFBZUEsQ0FBQzJDLE1BQU1MLFlBQVlDLGdCQUFnQkM7WUFDaEU5QixXQUFXLENBQUNnQyxPQUFVO29CQUNwQixHQUFHQSxJQUFJO29CQUNQLENBQUNDLEtBQUssRUFBRUY7Z0JBQ1Y7WUFDQSxPQUFPQTtRQUNULEVBQUUsT0FBT2pCLEtBQUs7WUFDWixNQUFNWSxVQUFVLDBCQUErRSxPQUFyRFosZUFBZVcsUUFBUVgsSUFBSVksT0FBTyxHQUFHO1lBQy9FdEIsU0FBU3NCO1lBQ1QsTUFBTVo7UUFDUjtJQUNGLEdBQ0EsRUFBRTtJQUdKLE1BQU1xQixhQUFhaEQsa0RBQVdBLENBQUMsQ0FBQzhDLE1BQWNMO1FBQzVDLElBQUk7WUFDRnJDLGlFQUF1QkEsQ0FBQzBDLE1BQU1MO1lBQzlCNUIsV0FBVyxDQUFDZ0M7Z0JBQ1YsTUFBTUksYUFBYTtvQkFBRSxHQUFHSixJQUFJO2dCQUFDO2dCQUM3QixJQUFJSSxVQUFVLENBQUNILEtBQUssRUFBRTtvQkFDcEIsT0FBT0csVUFBVSxDQUFDSCxLQUFLLENBQUNJLGVBQWUsQ0FBQ1QsV0FBVztvQkFDbkQsSUFBSVUsT0FBT0MsSUFBSSxDQUFDSCxVQUFVLENBQUNILEtBQUssQ0FBQ0ksZUFBZSxFQUFFRyxNQUFNLEtBQUssR0FBRzt3QkFDOUQsT0FBT0osVUFBVSxDQUFDSCxLQUFLO29CQUN6QixPQUFPO3dCQUNMRyxVQUFVLENBQUNILEtBQUssQ0FBQ1EsU0FBUyxHQUFHLElBQUlDLE9BQU9DLFdBQVc7b0JBQ3JEO2dCQUNGO2dCQUNBLE9BQU9QO1lBQ1Q7UUFDRixFQUFFLE9BQU90QixLQUFLO1lBQ1osTUFBTVksVUFBVSwwQkFBK0UsT0FBckRaLGVBQWVXLFFBQVFYLElBQUlZLE9BQU8sR0FBRztZQUMvRXRCLFNBQVNzQjtZQUNULE1BQU1aO1FBQ1I7SUFDRixHQUFHLEVBQUU7SUFFTCxNQUFNOEIsZ0JBQWdCekQsa0RBQVdBLENBQUM7UUFDaEMsT0FBT1ksT0FBTyxDQUFDTixzREFBY0EsR0FBRyxJQUFJO0lBQ3RDLEdBQUc7UUFBQ007S0FBUTtJQUVaLE1BQU04QyxpQkFBaUIxRCxrREFBV0EsQ0FDaEMsQ0FBQzhDO1FBQ0MsT0FBT2xDLE9BQU8sQ0FBQ2tDLEtBQUssSUFBSTtJQUMxQixHQUNBO1FBQUNsQztLQUFRO0lBR1gsTUFBTStDLGdCQUFnQjNELGtEQUFXQSxDQUFDO1FBQ2hDLE9BQU9tRCxPQUFPUyxNQUFNLENBQUNoRCxTQUFTaUQsSUFBSSxDQUNoQyxDQUFDQyxHQUFHQyxJQUNGLElBQUlSLEtBQUtRLEVBQUVqQixJQUFJLEVBQUVrQixPQUFPLEtBQUssSUFBSVQsS0FBS08sRUFBRWhCLElBQUksRUFBRWtCLE9BQU87SUFFM0QsR0FBRztRQUFDcEQ7S0FBUTtJQUVaLE9BQU87UUFDTEE7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQVE7UUFDQVk7UUFDQU87UUFDQUM7UUFDQVM7UUFDQUM7UUFDQUM7UUFDQU0sWUFBWSxJQUFNaEQsU0FBUztRQUMzQmlELHNCQUFzQixJQUFNL0MsbUJBQW1CO0lBQ2pEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9ob29rcy91c2VQYWluRGF0YS50cz9lZDhhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBQYWluRW50cnkgfSBmcm9tICcuLi9kYXRhLW1vZGVscyc7XHJcbmltcG9ydCB7XHJcbiAgbG9hZFBhaW5UcmFja2VyRGF0YSxcclxuICBhZGRQYWluRW50cnksXHJcbiAgdXBkYXRlUGFpbkxldmVsLFxyXG4gIGRlbGV0ZVBhaW5MZXZlbEZyb21EYXRlLFxyXG4gIHNhdmVQYWluVHJhY2tlckRhdGEsXHJcbn0gZnJvbSAnLi4vc3RvcmFnZSc7XHJcbmltcG9ydCB7IGdldFRvZGF5U3RyaW5nIH0gZnJvbSAnLi4vZGF0ZXMnO1xyXG5pbXBvcnQge1xyXG4gIGlzTWlncmF0aW9uTmVlZGVkLFxyXG4gIG1pZ3JhdGVBbGxMZWdhY3lFbnRyaWVzLFxyXG4gIGNyZWF0ZU1pZ3JhdGlvbkJhY2t1cCxcclxuICBnZXRNaWdyYXRpb25TdW1tYXJ5LFxyXG59IGZyb20gJy4uL21pZ3JhdGUtcGFpbi1kYXRhJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYWluRGF0YSgpIHtcclxuICBjb25zdCBbZW50cmllcywgc2V0RW50cmllc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBQYWluRW50cnk+Pih7fSk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbbWlncmF0aW9uU3RhdHVzLCBzZXRNaWdyYXRpb25TdGF0dXNdID0gdXNlU3RhdGU8J3BlbmRpbmcnIHwgJ25lZWRzLW1pZ3JhdGlvbicgfCAnbWlncmF0ZWQnIHwgJ25vLW1pZ3JhdGlvbicgfCAnZXJyb3InPigncGVuZGluZycpO1xyXG4gIGNvbnN0IFttaWdyYXRpb25TdW1tYXJ5LCBzZXRNaWdyYXRpb25TdW1tYXJ5XSA9IHVzZVN0YXRlPGFueSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBMb2FkIGRhdGEgb24gbW91bnQgYW5kIGRldGVjdCBpZiBtaWdyYXRpb24gaXMgbmVlZGVkIChkbyBOT1QgYXV0by1taWdyYXRlKVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gbG9hZFBhaW5UcmFja2VyRGF0YSgpO1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSBtaWdyYXRpb24gc3VtbWFyeSBhbmQgc2V0IHN0YXR1cyBpZiBsZWdhY3kgZGF0YSBwcmVzZW50XHJcbiAgICAgIGlmIChpc01pZ3JhdGlvbk5lZWRlZChkYXRhKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gZ2V0TWlncmF0aW9uU3VtbWFyeShkYXRhKTtcclxuICAgICAgICAgIHNldE1pZ3JhdGlvblN1bW1hcnkoc3VtbWFyeSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY29tcHV0ZSBtaWdyYXRpb24gc3VtbWFyeScsIGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gTk9UIHBlcmZvcm0gbWlncmF0aW9uIGF1dG9tYXRpY2FsbHk7IG1hcmsgYXMgbmVlZHMtbWlncmF0aW9uXHJcbiAgICAgICAgc2V0TWlncmF0aW9uU3RhdHVzKCduZWVkcy1taWdyYXRpb24nKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRNaWdyYXRpb25TdGF0dXMoJ25vLW1pZ3JhdGlvbicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRFbnRyaWVzKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBwYWluIGRhdGEnKTtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBNYW51YWwgbWlncmF0aW9uIHRyaWdnZXI6IGNhbGwgdGhpcyB3aGVuIHVzZXIgY2hvb3NlcyB0byBtaWdyYXRlXHJcbiAgY29uc3QgcGVyZm9ybU1pZ3JhdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBsb2FkUGFpblRyYWNrZXJEYXRhKCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYmFja3VwIGJlZm9yZSBtaWdyYXRpb25cclxuICAgICAgY29uc3QgYmFja3VwSnNvbiA9IGNyZWF0ZU1pZ3JhdGlvbkJhY2t1cChjdXJyZW50KTtcclxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgncGFpbkRhdGFCYWNrdXAnLCBiYWNrdXBKc29uKTtcclxuXHJcbiAgICAgIGNvbnN0IHsgbWlncmF0ZWRFbnRyaWVzLCBtaWdyYXRpb25UeXBlLCBzdGF0cyB9ID0gbWlncmF0ZUFsbExlZ2FjeUVudHJpZXMoY3VycmVudCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgTWlncmF0aW9uIGNvbXBsZXRlOiAke21pZ3JhdGlvblR5cGV9YCwgc3RhdHMpO1xyXG5cclxuICAgICAgLy8gU2F2ZSBtaWdyYXRlZCBkYXRhIGJhY2sgdG8gbG9jYWxTdG9yYWdlIGFuZCB1cGRhdGUgc3RhdGVcclxuICAgICAgc2F2ZVBhaW5UcmFja2VyRGF0YShtaWdyYXRlZEVudHJpZXMpO1xyXG4gICAgICBzZXRFbnRyaWVzKG1pZ3JhdGVkRW50cmllcyk7XHJcbiAgICAgIHNldE1pZ3JhdGlvblN0YXR1cyhtaWdyYXRpb25UeXBlID09PSAnbm8tbWlncmF0aW9uJyA/ICduby1taWdyYXRpb24nIDogJ21pZ3JhdGVkJyk7XHJcbiAgICB9IGNhdGNoIChtaWdyYXRpb25FcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgTWlncmF0aW9uIGVycm9yOicsIG1pZ3JhdGlvbkVycm9yKTtcclxuICAgICAgc2V0TWlncmF0aW9uU3RhdHVzKCdlcnJvcicpO1xyXG4gICAgICBzZXRFcnJvcihgTWlncmF0aW9uIGZhaWxlZDogJHttaWdyYXRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yID8gbWlncmF0aW9uRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHJlY29yZFBhaW4gPSB1c2VDYWxsYmFjayhcclxuICAgIChib2R5UGFydElkOiBzdHJpbmcsIGludGVuc2l0eUxldmVsOiBudW1iZXIsIHBhaW5UeXBlPzogc3RyaW5nKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZW50cnkgPSBhZGRQYWluRW50cnkoYm9keVBhcnRJZCwgaW50ZW5zaXR5TGV2ZWwsIHBhaW5UeXBlKTtcclxuICAgICAgICBzZXRFbnRyaWVzKChwcmV2KSA9PiAoe1xyXG4gICAgICAgICAgLi4ucHJldixcclxuICAgICAgICAgIFtlbnRyeS5kYXRlXTogZW50cnksXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBGYWlsZWQgdG8gcmVjb3JkIHBhaW46ICR7ZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xyXG4gICAgICAgIHNldEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFtdXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgdXBkYXRlUGFpbiA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGRhdGU6IHN0cmluZywgYm9keVBhcnRJZDogc3RyaW5nLCBpbnRlbnNpdHlMZXZlbDogbnVtYmVyLCBwYWluVHlwZT86IHN0cmluZykgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdXBkYXRlUGFpbkxldmVsKGRhdGUsIGJvZHlQYXJ0SWQsIGludGVuc2l0eUxldmVsLCBwYWluVHlwZSk7XHJcbiAgICAgICAgc2V0RW50cmllcygocHJldikgPT4gKHtcclxuICAgICAgICAgIC4uLnByZXYsXHJcbiAgICAgICAgICBbZGF0ZV06IGVudHJ5LFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgRmFpbGVkIHRvIHVwZGF0ZSBwYWluOiAke2VyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YDtcclxuICAgICAgICBzZXRFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbXVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IHJlbW92ZVBhaW4gPSB1c2VDYWxsYmFjaygoZGF0ZTogc3RyaW5nLCBib2R5UGFydElkOiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGRlbGV0ZVBhaW5MZXZlbEZyb21EYXRlKGRhdGUsIGJvZHlQYXJ0SWQpO1xyXG4gICAgICBzZXRFbnRyaWVzKChwcmV2KSA9PiB7XHJcbiAgICAgICAgY29uc3QgbmV3RW50cmllcyA9IHsgLi4ucHJldiB9O1xyXG4gICAgICAgIGlmIChuZXdFbnRyaWVzW2RhdGVdKSB7XHJcbiAgICAgICAgICBkZWxldGUgbmV3RW50cmllc1tkYXRlXS5ib2R5UGFydEVudHJpZXNbYm9keVBhcnRJZF07XHJcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3RW50cmllc1tkYXRlXS5ib2R5UGFydEVudHJpZXMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkZWxldGUgbmV3RW50cmllc1tkYXRlXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0VudHJpZXNbZGF0ZV0udXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3RW50cmllcztcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGBGYWlsZWQgdG8gcmVtb3ZlIHBhaW46ICR7ZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xyXG4gICAgICBzZXRFcnJvcihtZXNzYWdlKTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgZ2V0VG9kYXlFbnRyeSA9IHVzZUNhbGxiYWNrKCgpOiBQYWluRW50cnkgfCBudWxsID0+IHtcclxuICAgIHJldHVybiBlbnRyaWVzW2dldFRvZGF5U3RyaW5nKCldIHx8IG51bGw7XHJcbiAgfSwgW2VudHJpZXNdKTtcclxuXHJcbiAgY29uc3QgZ2V0RW50cnlCeURhdGUgPSB1c2VDYWxsYmFjayhcclxuICAgIChkYXRlOiBzdHJpbmcpOiBQYWluRW50cnkgfCBudWxsID0+IHtcclxuICAgICAgcmV0dXJuIGVudHJpZXNbZGF0ZV0gfHwgbnVsbDtcclxuICAgIH0sXHJcbiAgICBbZW50cmllc11cclxuICApO1xyXG5cclxuICBjb25zdCBnZXRBbGxFbnRyaWVzID0gdXNlQ2FsbGJhY2soKCk6IFBhaW5FbnRyeVtdID0+IHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGVudHJpZXMpLnNvcnQoXHJcbiAgICAgIChhLCBiKSA9PlxyXG4gICAgICAgIG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKClcclxuICAgICk7XHJcbiAgfSwgW2VudHJpZXNdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGVudHJpZXMsXHJcbiAgICBsb2FkaW5nLFxyXG4gICAgZXJyb3IsXHJcbiAgICBtaWdyYXRpb25TdGF0dXMsXHJcbiAgICBtaWdyYXRpb25TdW1tYXJ5LFxyXG4gICAgcGVyZm9ybU1pZ3JhdGlvbixcclxuICAgIHJlY29yZFBhaW4sXHJcbiAgICB1cGRhdGVQYWluLFxyXG4gICAgcmVtb3ZlUGFpbixcclxuICAgIGdldFRvZGF5RW50cnksXHJcbiAgICBnZXRFbnRyeUJ5RGF0ZSxcclxuICAgIGdldEFsbEVudHJpZXMsXHJcbiAgICBjbGVhckVycm9yOiAoKSA9PiBzZXRFcnJvcihudWxsKSxcclxuICAgIGFja25vd2xlZGdlTWlncmF0aW9uOiAoKSA9PiBzZXRNaWdyYXRpb25TdGF0dXMoJ25vLW1pZ3JhdGlvbicpLFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJsb2FkUGFpblRyYWNrZXJEYXRhIiwiYWRkUGFpbkVudHJ5IiwidXBkYXRlUGFpbkxldmVsIiwiZGVsZXRlUGFpbkxldmVsRnJvbURhdGUiLCJzYXZlUGFpblRyYWNrZXJEYXRhIiwiZ2V0VG9kYXlTdHJpbmciLCJpc01pZ3JhdGlvbk5lZWRlZCIsIm1pZ3JhdGVBbGxMZWdhY3lFbnRyaWVzIiwiY3JlYXRlTWlncmF0aW9uQmFja3VwIiwiZ2V0TWlncmF0aW9uU3VtbWFyeSIsInVzZVBhaW5EYXRhIiwiZW50cmllcyIsInNldEVudHJpZXMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJtaWdyYXRpb25TdGF0dXMiLCJzZXRNaWdyYXRpb25TdGF0dXMiLCJtaWdyYXRpb25TdW1tYXJ5Iiwic2V0TWlncmF0aW9uU3VtbWFyeSIsImRhdGEiLCJzdW1tYXJ5IiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyIiwicGVyZm9ybU1pZ3JhdGlvbiIsImN1cnJlbnQiLCJiYWNrdXBKc29uIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwibWlncmF0ZWRFbnRyaWVzIiwibWlncmF0aW9uVHlwZSIsInN0YXRzIiwibG9nIiwibWlncmF0aW9uRXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJyZWNvcmRQYWluIiwiYm9keVBhcnRJZCIsImludGVuc2l0eUxldmVsIiwicGFpblR5cGUiLCJlbnRyeSIsInByZXYiLCJkYXRlIiwidXBkYXRlUGFpbiIsInJlbW92ZVBhaW4iLCJuZXdFbnRyaWVzIiwiYm9keVBhcnRFbnRyaWVzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInVwZGF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImdldFRvZGF5RW50cnkiLCJnZXRFbnRyeUJ5RGF0ZSIsImdldEFsbEVudHJpZXMiLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiY2xlYXJFcnJvciIsImFja25vd2xlZGdlTWlncmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib/hooks/usePainData.ts\n"));

/***/ })

});