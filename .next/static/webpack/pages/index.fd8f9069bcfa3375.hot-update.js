"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/lib/storage.ts":
/*!****************************!*\
  !*** ./src/lib/storage.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addPainEntry: function() { return /* binding */ addPainEntry; },\n/* harmony export */   deletePainEntry: function() { return /* binding */ deletePainEntry; },\n/* harmony export */   deletePainLevelFromDate: function() { return /* binding */ deletePainLevelFromDate; },\n/* harmony export */   getAllPainEntries: function() { return /* binding */ getAllPainEntries; },\n/* harmony export */   getPainEntryByDate: function() { return /* binding */ getPainEntryByDate; },\n/* harmony export */   loadPainTrackerData: function() { return /* binding */ loadPainTrackerData; },\n/* harmony export */   savePainTrackerData: function() { return /* binding */ savePainTrackerData; },\n/* harmony export */   updatePainLevel: function() { return /* binding */ updatePainLevel; }\n/* harmony export */ });\n/* harmony import */ var _dates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dates */ \"./src/lib/dates.ts\");\n/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validation */ \"./src/lib/validation.ts\");\n\n\nconst STORAGE_KEY = \"painTracker\";\n/**\r\n * Storage operations for pain entries\r\n */ function loadPainTrackerData() {\n    try {\n        if (false) {}\n        const data = localStorage.getItem(STORAGE_KEY);\n        if (!data) {\n            return {};\n        }\n        return JSON.parse(data);\n    } catch (error) {\n        console.error(\"Failed to load pain tracker data:\", error);\n        return {};\n    }\n}\nfunction savePainTrackerData(entries) {\n    try {\n        if (false) {}\n        const jsonString = JSON.stringify(entries);\n        localStorage.setItem(STORAGE_KEY, jsonString);\n    } catch (error) {\n        if (error instanceof DOMException && error.code === 22) {\n            // QuotaExceededError\n            handleQuotaExceeded(entries);\n        } else {\n            console.error(\"Failed to save pain tracker data:\", error);\n        }\n    }\n}\nfunction handleQuotaExceeded(entries) {\n    // Delete oldest month of data\n    const sortedDates = Object.keys(entries).sort();\n    let itemsToDelete = 0;\n    const today = new Date();\n    const oneMonthAgo = new Date(today);\n    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);\n    const oneMonthAgoStr = oneMonthAgo.toISOString().split(\"T\")[0];\n    for (const date of sortedDates){\n        if (date < oneMonthAgoStr) {\n            delete entries[date];\n            itemsToDelete++;\n        }\n    }\n    if (itemsToDelete > 0) {\n        try {\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));\n            console.log(\"Automatically deleted \".concat(itemsToDelete, \" old entries to free up storage.\"));\n        } catch (error) {\n            console.error(\"Failed to save after cleanup:\", error);\n        }\n    }\n}\nfunction addPainEntry(bodyPartId, intensityLevel, painType) {\n    const entries = loadPainTrackerData();\n    const today = (0,_dates__WEBPACK_IMPORTED_MODULE_0__.getTodayString)();\n    if (!entries[today]) {\n        entries[today] = {\n            date: today,\n            bodyPartEntries: {},\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n    }\n    const bodyPartEntry = {\n        bodyPartId,\n        intensityLevel,\n        recordedAt: new Date().toISOString(),\n        painType: painType !== null && painType !== void 0 ? painType : \"unknown\"\n    };\n    entries[today].bodyPartEntries[bodyPartId] = bodyPartEntry;\n    entries[today].updatedAt = new Date().toISOString();\n    if (!(0,_validation__WEBPACK_IMPORTED_MODULE_1__.validatePainEntry)(entries[today])) {\n        throw new Error(\"Invalid pain entry for \".concat(bodyPartId));\n    }\n    savePainTrackerData(entries);\n    return entries[today];\n}\nfunction updatePainLevel(date, bodyPartId, intensityLevel, painType) {\n    var _entries_date_bodyPartEntries_bodyPartId, _entries_date;\n    const entries = loadPainTrackerData();\n    if (!entries[date]) {\n        throw new Error(\"No entry found for date \".concat(date));\n    }\n    var _ref;\n    const bodyPartEntry = {\n        bodyPartId,\n        intensityLevel,\n        recordedAt: new Date().toISOString(),\n        painType: (_ref = painType !== null && painType !== void 0 ? painType : (_entries_date = entries[date]) === null || _entries_date === void 0 ? void 0 : (_entries_date_bodyPartEntries_bodyPartId = _entries_date.bodyPartEntries[bodyPartId]) === null || _entries_date_bodyPartEntries_bodyPartId === void 0 ? void 0 : _entries_date_bodyPartEntries_bodyPartId.painType) !== null && _ref !== void 0 ? _ref : \"unknown\"\n    };\n    if (!(0,_validation__WEBPACK_IMPORTED_MODULE_1__.validateBodyPartEntry)(bodyPartEntry)) {\n        throw new Error(\"Invalid body part entry\");\n    }\n    entries[date].bodyPartEntries[bodyPartId] = bodyPartEntry;\n    entries[date].updatedAt = new Date().toISOString();\n    savePainTrackerData(entries);\n    return entries[date];\n}\nfunction deletePainEntry(date) {\n    const entries = loadPainTrackerData();\n    delete entries[date];\n    savePainTrackerData(entries);\n}\nfunction getPainEntryByDate(date) {\n    const entries = loadPainTrackerData();\n    return entries[date] || null;\n}\nfunction getAllPainEntries() {\n    const entries = loadPainTrackerData();\n    return Object.values(entries).sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n}\nfunction deletePainLevelFromDate(date, bodyPartId) {\n    const entries = loadPainTrackerData();\n    if (!entries[date]) {\n        throw new Error(\"No entry found for date \".concat(date));\n    }\n    delete entries[date].bodyPartEntries[bodyPartId];\n    entries[date].updatedAt = new Date().toISOString();\n    // If no body parts left, delete the entire day's entry\n    if (Object.keys(entries[date].bodyPartEntries).length === 0) {\n        delete entries[date];\n    }\n    savePainTrackerData(entries);\n    return entries[date] || {\n        date,\n        bodyPartEntries: {},\n        createdAt: \"\",\n        updatedAt: \"\"\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3N0b3JhZ2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUl5QztBQUMrQjtBQUd4RSxNQUFNRyxjQUFjO0FBRXBCOztDQUVDLEdBRU0sU0FBU0M7SUFDZCxJQUFJO1FBQ0YsSUFBSSxLQUFrQixFQUFhLEVBRWxDO1FBRUQsTUFBTUMsT0FBT0MsYUFBYUMsT0FBTyxDQUFDSjtRQUNsQyxJQUFJLENBQUNFLE1BQU07WUFDVCxPQUFPLENBQUM7UUFDVjtRQUVBLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0o7SUFDcEIsRUFBRSxPQUFPSyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxxQ0FBcUNBO1FBQ25ELE9BQU8sQ0FBQztJQUNWO0FBQ0Y7QUFFTyxTQUFTRSxvQkFBb0JDLE9BQWtDO0lBQ3BFLElBQUk7UUFDRixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7UUFFRCxNQUFNQyxhQUFhTixLQUFLTyxTQUFTLENBQUNGO1FBQ2xDUCxhQUFhVSxPQUFPLENBQUNiLGFBQWFXO0lBQ3BDLEVBQUUsT0FBT0osT0FBTztRQUNkLElBQUlBLGlCQUFpQk8sZ0JBQWdCUCxNQUFNUSxJQUFJLEtBQUssSUFBSTtZQUN0RCxxQkFBcUI7WUFDckJDLG9CQUFvQk47UUFDdEIsT0FBTztZQUNMRixRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtRQUNyRDtJQUNGO0FBQ0Y7QUFFQSxTQUFTUyxvQkFBb0JOLE9BQWtDO0lBQzdELDhCQUE4QjtJQUM5QixNQUFNTyxjQUFjQyxPQUFPQyxJQUFJLENBQUNULFNBQVNVLElBQUk7SUFDN0MsSUFBSUMsZ0JBQWdCO0lBQ3BCLE1BQU1DLFFBQVEsSUFBSUM7SUFDbEIsTUFBTUMsY0FBYyxJQUFJRCxLQUFLRDtJQUM3QkUsWUFBWUMsUUFBUSxDQUFDRCxZQUFZRSxRQUFRLEtBQUs7SUFDOUMsTUFBTUMsaUJBQWlCSCxZQUFZSSxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUU5RCxLQUFLLE1BQU1DLFFBQVFiLFlBQWE7UUFDOUIsSUFBSWEsT0FBT0gsZ0JBQWdCO1lBQ3pCLE9BQU9qQixPQUFPLENBQUNvQixLQUFLO1lBQ3BCVDtRQUNGO0lBQ0Y7SUFFQSxJQUFJQSxnQkFBZ0IsR0FBRztRQUNyQixJQUFJO1lBQ0ZsQixhQUFhVSxPQUFPLENBQUNiLGFBQWFLLEtBQUtPLFNBQVMsQ0FBQ0Y7WUFDakRGLFFBQVF1QixHQUFHLENBQ1QseUJBQXVDLE9BQWRWLGVBQWM7UUFFM0MsRUFBRSxPQUFPZCxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1FBQ2pEO0lBQ0Y7QUFDRjtBQUVPLFNBQVN5QixhQUNkQyxVQUFrQixFQUNsQkMsY0FBc0IsRUFDdEJDLFFBQWlCO0lBRWpCLE1BQU16QixVQUFVVDtJQUNoQixNQUFNcUIsUUFBUXpCLHNEQUFjQTtJQUU1QixJQUFJLENBQUNhLE9BQU8sQ0FBQ1ksTUFBTSxFQUFFO1FBQ25CWixPQUFPLENBQUNZLE1BQU0sR0FBRztZQUNmUSxNQUFNUjtZQUNOYyxpQkFBaUIsQ0FBQztZQUNsQkMsV0FBVyxJQUFJZCxPQUFPSyxXQUFXO1lBQ2pDVSxXQUFXLElBQUlmLE9BQU9LLFdBQVc7UUFDbkM7SUFDRjtJQUVBLE1BQU1XLGdCQUErQjtRQUNuQ047UUFDQUM7UUFDQU0sWUFBWSxJQUFJakIsT0FBT0ssV0FBVztRQUNsQ08sVUFBV0EscUJBQUFBLHNCQUFBQSxXQUFZO0lBQ3pCO0lBRUF6QixPQUFPLENBQUNZLE1BQU0sQ0FBQ2MsZUFBZSxDQUFDSCxXQUFXLEdBQUdNO0lBQzdDN0IsT0FBTyxDQUFDWSxNQUFNLENBQUNnQixTQUFTLEdBQUcsSUFBSWYsT0FBT0ssV0FBVztJQUVqRCxJQUFJLENBQUM5Qiw4REFBaUJBLENBQUNZLE9BQU8sQ0FBQ1ksTUFBTSxHQUFHO1FBQ3RDLE1BQU0sSUFBSW1CLE1BQU0sMEJBQXFDLE9BQVhSO0lBQzVDO0lBRUF4QixvQkFBb0JDO0lBQ3BCLE9BQU9BLE9BQU8sQ0FBQ1ksTUFBTTtBQUN2QjtBQUVPLFNBQVNvQixnQkFDZFosSUFBWSxFQUNaRyxVQUFrQixFQUNsQkMsY0FBc0IsRUFDcEJDLFFBQWlCO1FBWU16QiwwQ0FBQUE7SUFWekIsTUFBTUEsVUFBVVQ7SUFFaEIsSUFBSSxDQUFDUyxPQUFPLENBQUNvQixLQUFLLEVBQUU7UUFDbEIsTUFBTSxJQUFJVyxNQUFNLDJCQUFnQyxPQUFMWDtJQUM3QztRQU1hSztJQUpiLE1BQU1JLGdCQUErQjtRQUNuQ047UUFDQUM7UUFDQU0sWUFBWSxJQUFJakIsT0FBT0ssV0FBVztRQUNsQ08sVUFBV0EsQ0FBQUEsT0FBQUEscUJBQUFBLHNCQUFBQSxZQUFZekIsZ0JBQUFBLE9BQU8sQ0FBQ29CLEtBQUssY0FBYnBCLHFDQUFBQSwyQ0FBQUEsY0FBZTBCLGVBQWUsQ0FBQ0gsV0FBVyxjQUExQ3ZCLCtEQUFBQSx5Q0FBNEN5QixRQUFRLGNBQWhFQSxrQkFBQUEsT0FBb0U7SUFDakY7SUFFQSxJQUFJLENBQUNwQyxrRUFBcUJBLENBQUN3QyxnQkFBZ0I7UUFDekMsTUFBTSxJQUFJRSxNQUFPO0lBQ25CO0lBRUEvQixPQUFPLENBQUNvQixLQUFLLENBQUNNLGVBQWUsQ0FBQ0gsV0FBVyxHQUFHTTtJQUM1QzdCLE9BQU8sQ0FBQ29CLEtBQUssQ0FBQ1EsU0FBUyxHQUFHLElBQUlmLE9BQU9LLFdBQVc7SUFFaERuQixvQkFBb0JDO0lBQ3BCLE9BQU9BLE9BQU8sQ0FBQ29CLEtBQUs7QUFDdEI7QUFFTyxTQUFTYSxnQkFBZ0JiLElBQVk7SUFDMUMsTUFBTXBCLFVBQVVUO0lBQ2hCLE9BQU9TLE9BQU8sQ0FBQ29CLEtBQUs7SUFDcEJyQixvQkFBb0JDO0FBQ3RCO0FBRU8sU0FBU2tDLG1CQUFtQmQsSUFBWTtJQUM3QyxNQUFNcEIsVUFBVVQ7SUFDaEIsT0FBT1MsT0FBTyxDQUFDb0IsS0FBSyxJQUFJO0FBQzFCO0FBRU8sU0FBU2U7SUFDZCxNQUFNbkMsVUFBVVQ7SUFDaEIsT0FBT2lCLE9BQU80QixNQUFNLENBQUNwQyxTQUFTVSxJQUFJLENBQ2hDLENBQUMyQixHQUFHQyxJQUNGLElBQUl6QixLQUFLeUIsRUFBRWxCLElBQUksRUFBRW1CLE9BQU8sS0FBSyxJQUFJMUIsS0FBS3dCLEVBQUVqQixJQUFJLEVBQUVtQixPQUFPO0FBRTNEO0FBRU8sU0FBU0Msd0JBQ2RwQixJQUFZLEVBQ1pHLFVBQWtCO0lBRWxCLE1BQU12QixVQUFVVDtJQUVoQixJQUFJLENBQUNTLE9BQU8sQ0FBQ29CLEtBQUssRUFBRTtRQUNsQixNQUFNLElBQUlXLE1BQU0sMkJBQWdDLE9BQUxYO0lBQzdDO0lBRUEsT0FBT3BCLE9BQU8sQ0FBQ29CLEtBQUssQ0FBQ00sZUFBZSxDQUFDSCxXQUFXO0lBQ2hEdkIsT0FBTyxDQUFDb0IsS0FBSyxDQUFDUSxTQUFTLEdBQUcsSUFBSWYsT0FBT0ssV0FBVztJQUVoRCx1REFBdUQ7SUFDdkQsSUFBSVYsT0FBT0MsSUFBSSxDQUFDVCxPQUFPLENBQUNvQixLQUFLLENBQUNNLGVBQWUsRUFBRWUsTUFBTSxLQUFLLEdBQUc7UUFDM0QsT0FBT3pDLE9BQU8sQ0FBQ29CLEtBQUs7SUFDdEI7SUFFQXJCLG9CQUFvQkM7SUFDcEIsT0FBT0EsT0FBTyxDQUFDb0IsS0FBSyxJQUFJO1FBQUVBO1FBQU1NLGlCQUFpQixDQUFDO1FBQUdDLFdBQVc7UUFBSUMsV0FBVztJQUFHO0FBQ3BGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3RvcmFnZS50cz9hZmU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgUGFpbkVudHJ5LFxyXG4gIEJvZHlQYXJ0RW50cnksXHJcbn0gZnJvbSAnLi9kYXRhLW1vZGVscyc7XHJcbmltcG9ydCB7IGdldFRvZGF5U3RyaW5nIH0gZnJvbSAnLi9kYXRlcyc7XHJcbmltcG9ydCB7IHZhbGlkYXRlUGFpbkVudHJ5LCB2YWxpZGF0ZUJvZHlQYXJ0RW50cnkgfSBmcm9tICcuL3ZhbGlkYXRpb24nO1xyXG5pbXBvcnQgdHlwZSB7IFBhaW5UeXBlQ29kZSB9IGZyb20gJy4vdHlwZXMvcGFpblR5cGUnO1xyXG5cclxuY29uc3QgU1RPUkFHRV9LRVkgPSAncGFpblRyYWNrZXInO1xyXG5cclxuLyoqXHJcbiAqIFN0b3JhZ2Ugb3BlcmF0aW9ucyBmb3IgcGFpbiBlbnRyaWVzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQYWluVHJhY2tlckRhdGEoKTogUmVjb3JkPHN0cmluZywgUGFpbkVudHJ5PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHBhaW4gdHJhY2tlciBkYXRhOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzYXZlUGFpblRyYWNrZXJEYXRhKGVudHJpZXM6IFJlY29yZDxzdHJpbmcsIFBhaW5FbnRyeT4pOiB2b2lkIHtcclxuICB0cnkge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZW50cmllcyk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwganNvblN0cmluZyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5jb2RlID09PSAyMikge1xyXG4gICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3JcclxuICAgICAgaGFuZGxlUXVvdGFFeGNlZWRlZChlbnRyaWVzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIHBhaW4gdHJhY2tlciBkYXRhOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVF1b3RhRXhjZWVkZWQoZW50cmllczogUmVjb3JkPHN0cmluZywgUGFpbkVudHJ5Pik6IHZvaWQge1xyXG4gIC8vIERlbGV0ZSBvbGRlc3QgbW9udGggb2YgZGF0YVxyXG4gIGNvbnN0IHNvcnRlZERhdGVzID0gT2JqZWN0LmtleXMoZW50cmllcykuc29ydCgpO1xyXG4gIGxldCBpdGVtc1RvRGVsZXRlID0gMDtcclxuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgY29uc3Qgb25lTW9udGhBZ28gPSBuZXcgRGF0ZSh0b2RheSk7XHJcbiAgb25lTW9udGhBZ28uc2V0TW9udGgob25lTW9udGhBZ28uZ2V0TW9udGgoKSAtIDEpO1xyXG4gIGNvbnN0IG9uZU1vbnRoQWdvU3RyID0gb25lTW9udGhBZ28udG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xyXG5cclxuICBmb3IgKGNvbnN0IGRhdGUgb2Ygc29ydGVkRGF0ZXMpIHtcclxuICAgIGlmIChkYXRlIDwgb25lTW9udGhBZ29TdHIpIHtcclxuICAgICAgZGVsZXRlIGVudHJpZXNbZGF0ZV07XHJcbiAgICAgIGl0ZW1zVG9EZWxldGUrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpdGVtc1RvRGVsZXRlID4gMCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGVudHJpZXMpKTtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYEF1dG9tYXRpY2FsbHkgZGVsZXRlZCAke2l0ZW1zVG9EZWxldGV9IG9sZCBlbnRyaWVzIHRvIGZyZWUgdXAgc3RvcmFnZS5gXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBhZnRlciBjbGVhbnVwOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRQYWluRW50cnkoXHJcbiAgYm9keVBhcnRJZDogc3RyaW5nLFxyXG4gIGludGVuc2l0eUxldmVsOiBudW1iZXIsXHJcbiAgcGFpblR5cGU/OiBzdHJpbmdcclxuKTogUGFpbkVudHJ5IHtcclxuICBjb25zdCBlbnRyaWVzID0gbG9hZFBhaW5UcmFja2VyRGF0YSgpO1xyXG4gIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXlTdHJpbmcoKTtcclxuXHJcbiAgaWYgKCFlbnRyaWVzW3RvZGF5XSkge1xyXG4gICAgZW50cmllc1t0b2RheV0gPSB7XHJcbiAgICAgIGRhdGU6IHRvZGF5LFxyXG4gICAgICBib2R5UGFydEVudHJpZXM6IHt9LFxyXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYm9keVBhcnRFbnRyeTogQm9keVBhcnRFbnRyeSA9IHtcclxuICAgIGJvZHlQYXJ0SWQsXHJcbiAgICBpbnRlbnNpdHlMZXZlbCxcclxuICAgIHJlY29yZGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIHBhaW5UeXBlOiAocGFpblR5cGUgPz8gJ3Vua25vd24nKSBhcyBQYWluVHlwZUNvZGUsXHJcbiAgfTtcclxuXHJcbiAgZW50cmllc1t0b2RheV0uYm9keVBhcnRFbnRyaWVzW2JvZHlQYXJ0SWRdID0gYm9keVBhcnRFbnRyeTtcclxuICBlbnRyaWVzW3RvZGF5XS51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcblxyXG4gIGlmICghdmFsaWRhdGVQYWluRW50cnkoZW50cmllc1t0b2RheV0pKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFpbiBlbnRyeSBmb3IgJHtib2R5UGFydElkfWApO1xyXG4gIH1cclxuXHJcbiAgc2F2ZVBhaW5UcmFja2VyRGF0YShlbnRyaWVzKTtcclxuICByZXR1cm4gZW50cmllc1t0b2RheV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQYWluTGV2ZWwoXHJcbiAgZGF0ZTogc3RyaW5nLFxyXG4gIGJvZHlQYXJ0SWQ6IHN0cmluZyxcclxuICBpbnRlbnNpdHlMZXZlbDogbnVtYmVyXHJcbiAgLCBwYWluVHlwZT86IHN0cmluZ1xyXG4pOiBQYWluRW50cnkge1xyXG4gIGNvbnN0IGVudHJpZXMgPSBsb2FkUGFpblRyYWNrZXJEYXRhKCk7XHJcblxyXG4gIGlmICghZW50cmllc1tkYXRlXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBlbnRyeSBmb3VuZCBmb3IgZGF0ZSAke2RhdGV9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBib2R5UGFydEVudHJ5OiBCb2R5UGFydEVudHJ5ID0ge1xyXG4gICAgYm9keVBhcnRJZCxcclxuICAgIGludGVuc2l0eUxldmVsLFxyXG4gICAgcmVjb3JkZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgcGFpblR5cGU6IChwYWluVHlwZSA/PyBlbnRyaWVzW2RhdGVdPy5ib2R5UGFydEVudHJpZXNbYm9keVBhcnRJZF0/LnBhaW5UeXBlID8/ICd1bmtub3duJykgYXMgUGFpblR5cGVDb2RlLFxyXG4gIH07XHJcblxyXG4gIGlmICghdmFsaWRhdGVCb2R5UGFydEVudHJ5KGJvZHlQYXJ0RW50cnkpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm9keSBwYXJ0IGVudHJ5YCk7XHJcbiAgfVxyXG5cclxuICBlbnRyaWVzW2RhdGVdLmJvZHlQYXJ0RW50cmllc1tib2R5UGFydElkXSA9IGJvZHlQYXJ0RW50cnk7XHJcbiAgZW50cmllc1tkYXRlXS51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcblxyXG4gIHNhdmVQYWluVHJhY2tlckRhdGEoZW50cmllcyk7XHJcbiAgcmV0dXJuIGVudHJpZXNbZGF0ZV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQYWluRW50cnkoZGF0ZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgY29uc3QgZW50cmllcyA9IGxvYWRQYWluVHJhY2tlckRhdGEoKTtcclxuICBkZWxldGUgZW50cmllc1tkYXRlXTtcclxuICBzYXZlUGFpblRyYWNrZXJEYXRhKGVudHJpZXMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFpbkVudHJ5QnlEYXRlKGRhdGU6IHN0cmluZyk6IFBhaW5FbnRyeSB8IG51bGwge1xyXG4gIGNvbnN0IGVudHJpZXMgPSBsb2FkUGFpblRyYWNrZXJEYXRhKCk7XHJcbiAgcmV0dXJuIGVudHJpZXNbZGF0ZV0gfHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFBhaW5FbnRyaWVzKCk6IFBhaW5FbnRyeVtdIHtcclxuICBjb25zdCBlbnRyaWVzID0gbG9hZFBhaW5UcmFja2VyRGF0YSgpO1xyXG4gIHJldHVybiBPYmplY3QudmFsdWVzKGVudHJpZXMpLnNvcnQoXHJcbiAgICAoYSwgYikgPT5cclxuICAgICAgbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKVxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQYWluTGV2ZWxGcm9tRGF0ZShcclxuICBkYXRlOiBzdHJpbmcsXHJcbiAgYm9keVBhcnRJZDogc3RyaW5nXHJcbik6IFBhaW5FbnRyeSB7XHJcbiAgY29uc3QgZW50cmllcyA9IGxvYWRQYWluVHJhY2tlckRhdGEoKTtcclxuXHJcbiAgaWYgKCFlbnRyaWVzW2RhdGVdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGVudHJ5IGZvdW5kIGZvciBkYXRlICR7ZGF0ZX1gKTtcclxuICB9XHJcblxyXG4gIGRlbGV0ZSBlbnRyaWVzW2RhdGVdLmJvZHlQYXJ0RW50cmllc1tib2R5UGFydElkXTtcclxuICBlbnRyaWVzW2RhdGVdLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuXHJcbiAgLy8gSWYgbm8gYm9keSBwYXJ0cyBsZWZ0LCBkZWxldGUgdGhlIGVudGlyZSBkYXkncyBlbnRyeVxyXG4gIGlmIChPYmplY3Qua2V5cyhlbnRyaWVzW2RhdGVdLmJvZHlQYXJ0RW50cmllcykubGVuZ3RoID09PSAwKSB7XHJcbiAgICBkZWxldGUgZW50cmllc1tkYXRlXTtcclxuICB9XHJcblxyXG4gIHNhdmVQYWluVHJhY2tlckRhdGEoZW50cmllcyk7XHJcbiAgcmV0dXJuIGVudHJpZXNbZGF0ZV0gfHwgeyBkYXRlLCBib2R5UGFydEVudHJpZXM6IHt9LCBjcmVhdGVkQXQ6ICcnLCB1cGRhdGVkQXQ6ICcnIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbImdldFRvZGF5U3RyaW5nIiwidmFsaWRhdGVQYWluRW50cnkiLCJ2YWxpZGF0ZUJvZHlQYXJ0RW50cnkiLCJTVE9SQUdFX0tFWSIsImxvYWRQYWluVHJhY2tlckRhdGEiLCJkYXRhIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsInNhdmVQYWluVHJhY2tlckRhdGEiLCJlbnRyaWVzIiwianNvblN0cmluZyIsInN0cmluZ2lmeSIsInNldEl0ZW0iLCJET01FeGNlcHRpb24iLCJjb2RlIiwiaGFuZGxlUXVvdGFFeGNlZWRlZCIsInNvcnRlZERhdGVzIiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJpdGVtc1RvRGVsZXRlIiwidG9kYXkiLCJEYXRlIiwib25lTW9udGhBZ28iLCJzZXRNb250aCIsImdldE1vbnRoIiwib25lTW9udGhBZ29TdHIiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiZGF0ZSIsImxvZyIsImFkZFBhaW5FbnRyeSIsImJvZHlQYXJ0SWQiLCJpbnRlbnNpdHlMZXZlbCIsInBhaW5UeXBlIiwiYm9keVBhcnRFbnRyaWVzIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiYm9keVBhcnRFbnRyeSIsInJlY29yZGVkQXQiLCJFcnJvciIsInVwZGF0ZVBhaW5MZXZlbCIsImRlbGV0ZVBhaW5FbnRyeSIsImdldFBhaW5FbnRyeUJ5RGF0ZSIsImdldEFsbFBhaW5FbnRyaWVzIiwidmFsdWVzIiwiYSIsImIiLCJnZXRUaW1lIiwiZGVsZXRlUGFpbkxldmVsRnJvbURhdGUiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/storage.ts\n"));

/***/ })

});